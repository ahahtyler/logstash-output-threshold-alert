require 'amazon/sim'
require 'aws-sdk-for-ruby'
require 'rest-client'
require 'json'

require 'date'
require 'nokogiri'
require 'csv'
require_relative 'lib/folder.rb'
require_relative 'lib/service_line.rb'
require_relative 'lib/maxis_connection.rb'
require_relative 'lib/elasticsearch.rb'

def initialize_sim_api(materialSet, region)
	begin
	   credentials = Aws::OdinCredentials.new(materialSet)
	   return Amazon::SIM.new( :region            => region,
	 						   :access_key_id     => credentials.access_key_id,
							   :secret_access_key => credentials.secret_access_key)
	rescue
		puts "Sleeping for 10 seconds"
		sleep 10
		retry
	end
end

def collect_new_issues(guid)
	begin
       issues = @sim_conn.issues.filters(:assignedFolder => [guid], 
		                                 :createDate => [@yesterday, @today])
	rescue 
		puts "Sleeping for 10 seconds"
		sleep 10
		retry
	end
end

def create_label_combos
  supbt_labels = Hash.new

  label_block = @doc.css("label_config/supbt_labels/label")
  label_block.map {|node|  supbt_labels[node["name"]] = node["guid"]}

  supbt_labels["No Labels"]  = supbt_labels.values.join(" OR ")
  supbt_labels["All Labels"] = ""

  return supbt_labels
end

def create_team_list
  serviceArray = Array.new()
  @doc.css("teams/service").map do |service|
    serviceObj = ServiceLine.new(service["name"])
    service.css("group").map do |group|
      group.css("folder").map do |folder|
        name, guid = folder.css("guid").children, folder.css("name").children
        serviceObj.folders.push(Folder.new(name, guid, group["name"], @maxis))
      end
    end
    service.css("ignore_folders").map {|guid| serviceObj.ignoreFolder.push(guid.css("guid").children)}
    service.css("ignore_labels").map  {|guid| serviceObj.ignoreLabels.push(guid.css("guid").children)}
    serviceArray.push(serviceObj)
  end
  return serviceArray
end

def labelNames(guidArray)
	labelName = Array.new()
	guidArray.each {|guid| labelName << @labelHash.key(guid) if @labelHash.has_value?(guid)}
	labelName << "No Labels" if labelName.empty?
	return labelName
end

def folderName(folderGuid, serviceGroups)
	folderName, folderGroup, team = "", "", ""
	serviceGroups.each do |service|
		service.folders.each do |folder|
			folderName = folder.name if folderGuid.eql?(folder.guid)
			folderGroup = folder.group if folderGuid.eql?(folder.guid)
			team = service.name if folderGuid.eql?(folder.guid)
		end
	end
	folderName = "Unowned" if folderName.empty?
	folderGroup = "Unowned" if folderGroup.empty?
	team = "Unowned" if team.empty?
	
	return folderName, folderGroup, team
end

def generate_es_input(issues, folder, service)
  issues.each do |i|
	  	  
  	labelsArray = Array.new()
	i.labels.each { |l| labelsArray << l.id }
	  
    es_data_point ={ 'issue_id'      => i.id ,
                     'create_date'   => DateTime.now,
                     'touched'       => false,
		             '@timestamp'    => DateTime.parse((i.created.utc).to_s),
					 'team'          => service.name,		
                     'folder_group'  => folder.group.delete(' '),		
                     'folder_name'   => folder.name.delete(' '),
                     'folder_guid'   => folder.guid,
		             'label_guids'   => labelsArray,
		 		     'labels'        => labelNames(labelsArray),
		             'ftt_user'      => "",
		             'ticket_status' => "New", 
                     'touch_date'    => "",
                     'time_open'     => 0,
					 'run_id'        => @run_id }
	@new_issues.push(es_data_point)
  end
end

def find_resolvers(serviceGroups)
	resolverGroups = Hash.new()
	@doc.css("teams/service").map do |service|
	  service.css("group").map do |group|
		group.css("folder").map do |folder|
		  resolver = Array.new
		  folder.css("resolvers").search('value').each do |value| 
			(defined?  resolver) ? resolver << value.inner_html.tr('\"', '') : resolver = [value.inner_html]
		  end
		  resolverGroups[folder.css("guid").inner_html] = resolver
		end
	  end
	end

	materialSet = "com.amazon.supbt.fluxo.flx-sup-bt"
	credentials = Aws::OdinCredentials.new(materialSet)

	@my_user = credentials.access_key_id
	@my_pass = credentials.secret_access_key

	uniqueGroups = Array.new
	resolverGroups.each {|f, g| g.each {|t| uniqueGroups << t}}
	uniqueGroups = uniqueGroups.uniq

	uniqueHash = Hash.new()
	uniqueGroups.each do |rgroup|
		puts "Resolver group: #{rgroup}"		
		users = Array.new

		@url = "https://wfa-api.amazon.com/?Operation=ListResolverGroups&id=#{rgroup.tr(' ', '+')}&record_type=individuals"

		begin
			results = RestClient::Request.execute(:url => @url, :user => @my_user, :password => @my_pass, :method => :get, :verify_ssl => false)
		rescue Exception => e
			puts "Exception: #{e.inspect}"
			sleep 5
			retry
		end

		html_results = Nokogiri::HTML(results)
		html_results.css("listresolvergroupsresponse/listresolvergroupsresult/results_list").each do |result|
			result.css("result").each_with_index do |r, index|
				next if index%2==0
				users << "#{r.inner_html}"
			end
		end

		uniqueHash[rgroup] = users

	end

	resolverGroups.each do |fguid, rgroups|
		iusers = Array.new
		rgroups.each do |group|
			uniqueHash[group].each {|i| iusers << "kerberos:#{i}@ANT.AMAZON.COM"}
		end
		resolverGroups[fguid] = iusers.uniq
	end
	
   return resolverGroups
end
	
@host        = 'maxis-service-prod-pdx.amazon.com'
@scheme      = 'https'
@region      = 'us-west-2'
@materialSet = 'com.amazon.credentials.isengard.968648960172.user/stigty'

@es_server = "supbtsearch.corp.amazon.com"
@es_index  = "ftt_metrics"

@input_file  = File.expand_path(File.join(File.dirname(__FILE__), "input/maxis-input.xml"))
@doc         = Nokogiri::XML(File.open(@input_file))

@today     = Time.parse(DateTime.now.strftime("%Y-%m-%dT08:00:00.000Z").to_s)
@yesterday = Time.parse((DateTime.now - 1).strftime("%Y-%m-%dT08:00:00.000Z").to_s)
#@yesterday = Time.parse(DateTime.now.strftime("%Y-01-01T08:00:00.000Z").to_s)

@run_id = SecureRandom.uuid.gsub('-','')
puts "Run ID: #{@run_id}"

@maxis    = MaxisConnection.new(@host, @scheme, @region, @materialSet)
@elastic  = Elasticsearch.new(@es_server)
@sim_conn = initialize_sim_api(@materialSet, @region)

@labelHash     = create_label_combos
serviceGroups = create_team_list
resolverHash  = find_resolvers(serviceGroups)

puts @today
puts @yesterday

@new_issues = Array.new
serviceGroups.each do |service|
  puts "Starting Searches for: #{service.name}"
  service.folders.each do |folder|
	puts "Current folder: #{folder.name}"
	  issues = collect_new_issues(folder.guid)
      generate_es_input(issues, folder, service)
  end
end

@elastic.write_to_index(@es_index, @new_issues)
sleep 30
begin
	es_results = @elastic.get_results(@es_index, "touched:(false)%20AND%20ticket_status:(Open,New)")
rescue
	es_results = Array.new
end

puts "Resutls #{es_results.count}"

es_results.each do |r|
  issue_id = r["_source"]["issue_id"]	
  beenTouched, touchDate, actor = false, "", ""

  edits = @maxis.get("/issues/#{issue_id}/edits")
	#Check if not nil...
  edits["edits"].each do |e|
	e["pathEdits"].each do |p|
	  if p["path"].include?("/conversation") && resolverHash[r["_source"]["folder_guid"]].include?(e["actualOriginator"])
		  actor = e["actualOriginator"]
		  touchDate = e["actualCreateDate"]
		  beenTouched = true
	  end
	end
	break if beenTouched
  end

  puts "--------"
  puts "Current Issue: #{issue_id}"
  puts "Ticket Creation Date: #{Time.parse(r["_source"]["@timestamp"]).utc}" #PDT timezone

  details = @maxis.get("/issues/#{issue_id}")
	
  unless details['status'].eql?(r["_source"]["ticket_status"])	
	  puts "Changing Status"
	  @elastic.update_es_item(@es_index, "ticket_status", details['status'], r["_id"])
  end

  sim_labels = Array.new
  details['labels'].each {|l| sim_labels << l['id']}
  unless sim_labels.to_set == r["_source"]["label_guids"].to_set
	  puts "Changing labels"
	  labelGuidsArray = Array.new()
	  details['labels'].each {|l| labelGuidsArray << l['id']}
	  @elastic.update_es_item(@es_index, "label_guids", labelGuidsArray, r["_id"])		
	  @elastic.update_es_item(@es_index, "labels", labelNames(labelGuidsArray), r["_id"])
  end

  unless details['assignedFolder'].eql?(r["_source"]["folder_guid"])	
	  puts "Changing folder"
	  folderName, folderGroup, team = folderName(details['assignedFolder'], serviceGroups)
	  @elastic.update_es_item(@es_index, "folder_guid", details['assignedFolder'], r["_id"])
	  @elastic.update_es_item(@es_index, "folder_name", folderName, r["_id"])
	  @elastic.update_es_item(@es_index, "folder_group", folderGroup, r["_id"])
	  @elastic.update_es_item(@es_index, "team", team, r["_id"])
  end

  if beenTouched
	  puts "Issue was touched on: #{Time.parse(touchDate).utc}" #GMT timezone
	  puts "Issue has been touched by #{actor}"
	  touchedTimeSec =  (Time.parse(touchDate).utc - Time.parse(r["_source"]["@timestamp"]).utc).round
	  puts "Seconds until touched #{touchedTimeSec}" 
	  puts "Minutes until touched #{(touchedTimeSec/60).round}" 
	  @elastic.update_es_item(@es_index, "ftt_user", actor, r["_id"])
	  @elastic.update_es_item(@es_index, "touched", "true", r["_id"])
	  @elastic.update_es_item(@es_index, "touch_date", Time.parse(touchDate).utc.to_s, r["_id"])
	  @elastic.update_es_item(@es_index, "time_open", (touchedTimeSec/60).round, r["_id"])
  else
	  #If resolved and hasn't been touched put resolved date
	  if details['status'].eql?("Resolved")
		    beenResolved, resolvedDate, actor = false, "", ""
			edits["edits"].each do |e|
				e["pathEdits"].each do |p|
					if p["path"].include?("/status") && p["data"].eql?("Resolved")
					  actor = e["actualOriginator"]
					  resolvedDate = e["actualCreateDate"]
					  beenResolved = true
					end
				end
				break if beenResolved
			end

		  openTimeSec = (Time.parse(resolvedDate).utc - Time.parse(r["_source"]["@timestamp"]).utc).round
		  puts "Seconds issue has been Resolved: #{openTimeSec}"
		  puts "Minutes until touched #{(openTimeSec/60).round}" 

		  @elastic.update_es_item(@es_index, "time_open",(openTimeSec/60).round, r["_id"])
	  else
		  openTimeSec = (Time.now.utc - Time.parse(r["_source"]["@timestamp"]).utc).round
		  puts "Seconds issue has been untouched: #{openTimeSec}"
		  puts "Minutes until touched #{(openTimeSec/60).round}" 

		  @elastic.update_es_item(@es_index, "time_open",(openTimeSec/60).round, r["_id"])
	  end
	  
  end	
 
end
