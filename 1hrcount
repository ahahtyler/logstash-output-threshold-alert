require 'date'
require 'nokogiri'
require 'rest-client'
require 'csv'
require_relative 'lib/folder.rb'
require_relative 'lib/service_line.rb'
require_relative 'lib/maxis_connection.rb'
require_relative 'lib/elasticsearch.rb'

@host        = 'maxis-service-prod-pdx.amazon.com'
@scheme      = 'https'
@region      = 'us-west-2'
@materialSet = 'com.amazon.credentials.isengard.968648960172.user/stigty'
@es_server   = "supbtsearch.corp.amazon.com"
@es_index    = "count_metrics_1hr"
@input_file  = File.expand_path(File.join(File.dirname(__FILE__), "input/maxis-input.xml"))
@run_id      = SecureRandom.uuid.gsub('-','')

def create_time_ranges
  today = DateTime.now.strftime("%Y-%m-%dT%H:00:00.000Z")
  hr1   = (DateTime.now - (1.0/24.0)).strftime("%Y-%m-%dT%H:00:00.000Z")
  bot   = "*"
  return { 'hr1' => {'start' => hr1  ,  'end' => today},
	       'bot' => {'start' => bot  ,  'end' => today}}
end

def create_label_combos
  supbt_labels = Hash.new

  label_block = @doc.css("label_config/supbt_labels/label")
  label_block.map {|node|  supbt_labels[node["name"]] = node["guid"]}

  supbt_labels["No Labels"]  = supbt_labels.values.join(" OR ")
  supbt_labels["All Labels"] = ""

  return supbt_labels
end

def create_team_list
  serviceArray = Array.new()
  @doc.css("teams/service").map do |service|
    serviceObj = ServiceLine.new(service["name"])
    service.css("group").map do |group|
      group.css("folder").map do |folder|
        name, guid = folder.css("guid").children, folder.css("name").children
        serviceObj.folders.push(Folder.new(name, guid, group["name"], @maxis))
      end
    end
    service.css("ignore_folders").map {|guid| serviceObj.ignoreFolder.push(guid.css("guid").children)}
    service.css("ignore_labels").map  {|guid| serviceObj.ignoreLabels.push(guid.css("guid").children)}
    serviceArray.push(serviceObj)
  end
  return serviceArray
end

def build_payload(service, folder, dateRange, labelName, labelGuid, searchType)

  payload = ""
  payload_fields = ["folderType", "assignedFolder", "containingFolder", "createDate",
                    "lastResolvedDate", "status", "-containingFolder", "aggregatedLabels",
                    "-aggregatedLabels", "next_step.owner:role"]

  payload_fields.each do |field|
    case field
      when "folderType"
        payload += "#{field}:(Default)"
      when "assignedFolder"
        payload += "#{field}:(#{folder.guid})" if folder.has_parent?
      when "containingFolder"
        payload += "#{field}:(#{folder.guid})" if !folder.has_parent?
      when "-containingFolder"
        payload += "#{field}:(#{service.ignoreFolder.join(" OR ")})" if !service.ignoreFolder.empty?
      when "createDate"
        payload += "#{field}:[#{dateRange['start']} TO #{dateRange['end']}]" if !searchType.eql?("Resolved")
      when "lastResolvedDate"
        payload += "#{field}:[#{dateRange['start']} TO #{dateRange['end']}]" if searchType.eql?("Resolved")
      when "status"
        payload += "#{field}:(Open)"     if ["Open", "Actionable"].include?(searchType)
        payload += "#{field}:(Resolved)" if ["Resolved"].include?searchType
      when "aggregatedLabels"
        payload += "#{field}:(#{labelGuid})" if ["SupBT", "Handoff", "SysEng"].include?(labelName)
      when "-aggregatedLabels"
        payload += "#{field}:(#{labelGuid})" if service.ignoreLabels.empty? && labelName.eql?("No Labels")
        payload += "#{field}:(#{service.ignoreLabels.join(" OR ")} OR #{labelGuid})" if !service.ignoreLabels.empty? && labelName.eql?("No Labels")
        payload += "#{field}:(#{service.ignoreLabels.join(" OR ")})" if !service.ignoreLabels.empty? && !labelName.eql?("No Labels")
      when "next_step.owner:role"
        payload += "#{field}\\:resolver" if searchType.eql?("Actionable")
    end
  end
  return @maxis.encode(payload)
end

def store_results(results, service, folder, searchType, labelName, query, dateKey)
  es_data_point = { 'count'        => results['totalNumberFound'],
                    'team'         => service.name,
                    'folder_group' => folder.group,
                    'folder_name'  => folder.name,
                    'folder_guid'  => folder.guid,
                    'search_type'  => searchType,
                    'label'        => labelName,
                    'maxis_query'  => query,
                    'sim_query'    => 'not yet',
                    'timeframe'    => dateKey,
                    'run_id'       => @run_id,
                    '@timestamp'   => DateTime.now.strftime("%Y-%m-%dT%H:00:00.000Z")}
  @results.push(es_data_point)
end

def skip?(service, searchType, dateKey, labelName)    
    case searchType
        when "New Issue"
            valid_label_names = ["All Labels"]
            if valid_label_names.include?(dateKey) 
                return false
            else
                return true
            end
        when "Actionable"
            valid_date_keys = ["bot"]
            valid_label_names = ["SupBT", "All Labels"]
			if valid_date_keys.include?(dateKey) && valid_label_names.include?(labelName)
                return false
            else
                return true
            end
        else
            return false
    end
end

def call_maxis(service, folder)
  @labelHash.each do |labelName, labelGuid|
    @dateHash.each do |dateKey, dateRange|
      @searchTypes.each do |searchType|
		next if skip?(service, searchType, dateKey, labelName)
        query = build_payload(service, folder, dateRange, labelName, labelGuid, searchType)
        results = @maxis.get(query)
        store_results(results, service, folder, searchType, labelName, query, dateKey)
      end
    end
  end
end

def write_to_csv
 puts "Writing results to /tmp/supbt-metrics-#{DateTime.now.strftime("%Y-%m-%dT%H:00:00.000Z")}-out.csv"
 CSV.open("/tmp/supbt-metrics-1hr-#{DateTime.now.strftime("%Y-%m-%dT%H:00:00.000Z")}-out.csv", "wb") do |csv|
   @results.each do |val|
     csv << [val['count'], val['team'], val['folder_group'], val['folder_name'], val['folder_guid'], val['search_type'], 
		     val['label'], val['maxis_query'], val['sim_query'], val['timeframe'], val['run_id'], val['@timestamp']]
   end
 end
end

begin
          
  puts "Script running on: #{`hostname`.chomp} at #{DateTime.now}"	
  puts "Script RUN_ID: #{@run_id}"	
	
  @doc         = Nokogiri::XML(File.open(@input_file))
  @searchTypes = ["New Issue", "Actionable"]	
	
  @maxis = MaxisConnection.new(@host, @scheme, @region, @materialSet)

  @labelHash    = create_label_combos
  @dateHash     = create_time_ranges
  serviceGroups = create_team_list
		
  @results = Array.new()
	
  serviceGroups.each do |service|
	puts "Starting Searches for: #{service.name}"
    service.folders.each do |folder|
	  puts "Current folder: #{folder.name}"
      call_maxis(service, folder)
    end
  end
  
  write_to_csv	
	
  elastic = Elasticsearch.new(@es_server)
  elastic.write_to_index(@es_index, @results)
    
rescue Exception => e
  puts "Backtrace: #{e.backtrace}\nResponse: #{e.inspect}"
end
